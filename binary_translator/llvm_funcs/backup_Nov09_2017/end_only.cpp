// Generated by llvm2cpp - DO NOT MODIFY!
#include <type_traits>

#include "llvm/Pass.h"
#include "llvm/PassManager.h"
#include "llvm/IRReader/IRReader.h"
#include "llvm/ADT/Statistic.h"
#include "llvm/ADT/StringRef.h"
#include "llvm/ADT/APInt.h"
#include "llvm/IR/LLVMContext.h"
#include "llvm/IR/BasicBlock.h"
#include "llvm/IR/CallingConv.h"
#include "llvm/IR/Constants.h"
#include "llvm/IR/DerivedTypes.h"
#include "llvm/IR/GlobalVariable.h"
#include "llvm/IR/IRPrintingPasses.h"
#include "llvm/IR/InlineAsm.h"
#include "llvm/IR/Instructions.h"
#include "llvm/IR/IRBuilder.h"
#include "llvm/IR/Value.h"
#include "llvm/IR/Module.h"
#include "llvm/IR/Function.h"
#include "llvm/IR/CFG.h"
#include "llvm/Pass.h"
#include "llvm/Support/raw_ostream.h"
#include "llvm/Support/SourceMgr.h"

using namespace llvm;

Function* define_pp_end(Module *mod) {

  // Type Definitions
  std::vector<Type*>FuncTy_0_args;
  FuncTy_0_args.push_back(IntegerType::get(mod->getContext(), 64));
  FunctionType* FuncTy_0 = FunctionType::get(
      /*Result=*/Type::getVoidTy(mod->getContext()),
      /*Params=*/FuncTy_0_args,
      /*isVarArg=*/false);

  PointerType* PointerTy_1 = PointerType::get(IntegerType::get(mod->getContext(), 64), 0);

  PointerType* PointerTy_2 = PointerType::get(IntegerType::get(mod->getContext(), 8), 0);

  ArrayType* ArrayTy_4 = ArrayType::get(IntegerType::get(mod->getContext(), 8), 17);

  PointerType* PointerTy_3 = PointerType::get(ArrayTy_4, 0);

  std::vector<Type*>FuncTy_6_args;
  FuncTy_6_args.push_back(PointerTy_2);
  FunctionType* FuncTy_6 = FunctionType::get(
      /*Result=*/IntegerType::get(mod->getContext(), 32),
      /*Params=*/FuncTy_6_args,
      /*isVarArg=*/true);

  PointerType* PointerTy_5 = PointerType::get(FuncTy_6, 0);


  // Function Declarations

  Function* func_printf = mod->getFunction("printf");
  if (!func_printf) {
    func_printf = Function::Create(
        /*Type=*/FuncTy_6,
        /*Linkage=*/GlobalValue::ExternalLinkage,
        /*Name=*/"printf", mod); // (external, no body)
    func_printf->setCallingConv(CallingConv::C);
  }
  AttributeSet func_printf_PAL;
  {
    SmallVector<AttributeSet, 4> Attrs;
    AttributeSet PAS;
    {
      AttrBuilder B;
      PAS = AttributeSet::get(mod->getContext(), ~0U, B);
    }

    Attrs.push_back(PAS);
    func_printf_PAL = AttributeSet::get(mod->getContext(), Attrs);

  }
  func_printf->setAttributes(func_printf_PAL);

  // Global Variable Declarations

  GlobalVariable* gvar_array__str = new GlobalVariable(/*Module=*/*mod, 
      /*Type=*/ArrayTy_4,
      /*isConstant=*/true,
      /*Linkage=*/GlobalValue::PrivateLinkage,
      /*Initializer=*/0, // has initializer, specified below
      /*Name=*/".str");
  gvar_array__str->setAlignment(1);

  // Constant Definitions
  ConstantInt* const_int32_7 = ConstantInt::get(mod->getContext(), APInt(32, StringRef("1"), 10));
  std::vector<Constant*> const_ptr_8_indices;
  ConstantInt* const_int32_9 = ConstantInt::get(mod->getContext(), APInt(32, StringRef("0"), 10));
  const_ptr_8_indices.push_back(const_int32_9);
  const_ptr_8_indices.push_back(const_int32_9);
  Constant* const_ptr_8 = ConstantExpr::getGetElementPtr(gvar_array__str, const_ptr_8_indices);
  Constant *const_array_10 = ConstantDataArray::getString(mod->getContext(), "Ending pp id %ld", true);

  // Global Variable Definitions
  gvar_array__str->setInitializer(const_array_10);

  Function* func_pp_end = mod->getFunction("pp_end");
  if (!func_pp_end) {
    func_pp_end = Function::Create(
        /*Type=*/FuncTy_0,
        /*Linkage=*/GlobalValue::ExternalLinkage,
        /*Name=*/"pp_end", mod); 
    func_pp_end->setCallingConv(CallingConv::C);
  }
  AttributeSet func_pp_end_PAL;
  {
    SmallVector<AttributeSet, 4> Attrs;
    AttributeSet PAS;
    {
      AttrBuilder B;
      B.addAttribute(Attribute::NoUnwind);
      B.addAttribute(Attribute::UWTable);
      PAS = AttributeSet::get(mod->getContext(), ~0U, B);
    }

    Attrs.push_back(PAS);
    func_pp_end_PAL = AttributeSet::get(mod->getContext(), Attrs);

  }
  func_pp_end->setAttributes(func_pp_end_PAL);
  Function::arg_iterator args = func_pp_end->arg_begin();
  Value* int64_pp_id = args++;
  int64_pp_id->setName("pp_id");

  BasicBlock* label_entry = BasicBlock::Create(mod->getContext(), "entry",func_pp_end,0);

  // Block entry (label_entry)
  AllocaInst* ptr_pp_id_addr = new AllocaInst(IntegerType::get(mod->getContext(), 64), "pp_id.addr", label_entry);
  ptr_pp_id_addr->setAlignment(8);
  StoreInst* void_11 = new StoreInst(int64_pp_id, ptr_pp_id_addr, false, label_entry);
  void_11->setAlignment(8);
  LoadInst* int64_12 = new LoadInst(ptr_pp_id_addr, "", false, label_entry);
  int64_12->setAlignment(8);
  std::vector<Value*> int32_call_params;
  int32_call_params.push_back(const_ptr_8);
  int32_call_params.push_back(int64_12);
  CallInst* int32_call = CallInst::Create(func_printf, int32_call_params, "call", label_entry);
  int32_call->setCallingConv(CallingConv::C);
  int32_call->setTailCall(false);
  AttributeSet int32_call_PAL;
  int32_call->setAttributes(int32_call_PAL);

  ReturnInst::Create(mod->getContext(), label_entry);
  return func_pp_end;
}
